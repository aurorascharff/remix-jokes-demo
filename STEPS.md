# DEMO STEPS

## Setup and starting point

Let's review the setup and starting point. I'm using React Router v7 here, then tailwind for CSS and a local db with sqlite. I'm using Prisma to interact with the database.

## All features

Be in fullscreen version.

Show the app. We have a list of jokes, a form to add new jokes, and a way to navigate. View jokes, add new link, create (funny joke), delete.

## Boilerplate

Go to split view.

We recognize the boilerplate from the slides. We have a `react-router.config.js` file, a `tsconfig.json` file, a `routes` folder, a `components` folder, a `lib` folder, a `app` folder, and a `prisma` folder. Eslint and prettier are also set up. And i revealed the entry.server and entry.client files.

The .react-router folder here is autogenerated to provide type safety to our routes which is a bvery new feature that is currently being improved.

## Routing: /routes, routes.ts

Let's start with the routes folder. I'm using file-based routing here and my RRM's are defined as files, and we have to follow a certain convnetion. THis is called flat routes, we define routes with dot and other chars. Maybe you like it, maybe you dont. Common in most metaframeworks, but with very different rules. There is also a code-option as mentioned. Show routes.ts file to define code based routing. Route modules are code split so we can lazily load js as we navigate to new routes for better performance.

## Routes: root.tsx

Start with root.tsx. This is the root layout. It's reurning the root document with the metadata and links that are collected from linkfunctions and metafunctions for route modules, and inserted into the head. It's then returning the children of the layout, which is the default export, App. It's using nested layouts to render the children.

Dont show error boundary.

## UI: Index.tsx

Lets look at Index.tsx. Showcase in app the page. Use the web! Central part of Remix. Remix feels familiar to oldschool devs. Less reacty. Learning the web when learning Remix. This is a Remix Route Module for the index page. It's using the Remix Link component to provide client side navigation and prefetch on hover for example. It's also definitng metadata to be collected for the head with this metafunction.

## CSS: Index.tsx

Index.tsx. Here I'm using tailwind, but Remix also has this feature called links. This is a way to solve performance issues with CSS. You can use links to load CSS only when needed. It defined a linkFunction that returns a link to the CSS file. Not using it here.

## Data fetching: Jokes.tsx

Lets move to the rest of the files. Jokes.tsx. Go to jokes in demo. Another route module for the url /jokes. This route module has a loader! Fetching data from the database - a list of jokes. It's using Prisma to interact with the database. It's using the loader to fetch the data and return it to the component using the loaderData prop and type safe Route.ComponentProps. We dont need useeffect fetching, kind of like getServerSideProps in Next.js.

We will start to see some unfamiliar, Remix specific hooks around here. This one is called useNavigation. It will give you the current state of the navigation, and provide i.e whether the router is navigating, which we use here to mark the page as pending with css. This hook adds ontop of our base case HTMK web standard document with additional client-side, js enhanced features. This is Remix's way to do progressive enhancement.

## Layouts: Jokes.tsx

It's defining lots of UI from this default component. A header, a sidebar with jokes and Links, and a footer. Inbetween there is a Outlet component for defining this routes children routes, using nested layouts here. This allows us to build complex UIs. And remix can fetch data for all nested routes in parallell.

The index route is the default child of the jokes route, and is rendered in the outlet on the route. It's using a loader to fetch a random joke. Throws a 404 if no joke is found.

## Errors: Index.tsx

Error boundaries for each route module using useRouteError. Here we catch the error that might occur when posting a new joke to the db. We can show a custom error message here. We can also use the error hook to get the error and show it in the UI. Here catching a 404 error to display a custom message with a link to the jokes page.

## Mutations: Jokes.new.tsx

Lets move to the jokes.new.tsx route module. Default export has a form. Don't worry about this optimistic update yet let's just look at the form. Remix Form component will provide extra features ontop of default form component, such as client side nav avoiding full page reload.

There is a method post on this, which will call the route for the route module with its action. The action validates using zod and returns errors if invalid inside a badrequest wrapper. Customizable. Then it redirects. Show console of network tab to show the post and get requests. GET data joke.new. POST data joke.new with localation. New GET for revalidation.

We dont need api routes to talk to our server from the client.

We also now create this additional UI enhancement with a isSumitting value, that checks whether the navigation is not idle and is on the action "jokes/new". It will disable the button when the form submits.

In addition it's doing optimistic UI by returning a view of a JokeDisplay if the validation succeeds. This is a client side update that will show the joke in the list before the server has responded.

## Revalidation: Jokes.new.tsx

Data is automatically revalidates. No fuss with adding items to lists. It's always the same. No manual revalidation. It's always in sync with the server. We can push or filter lists client side.

Show network tab loading and revalidating.

## RRM for single joke: joke.$jokeid.tsx

Lets move to a more complex route module with lots of features.

Go to joke.$jokeid.tsx. This is a dynamic route with params. Show it in the app. It's a route module for a single joke. It's using the loader to fetch the data for the joke with the id from the database. It's using the loaderData prop to pass the data to the component, and throw a 404 if no joke is found.

It's also using the useRouteError hook to catch any errors that might occur when fetching the data. It's using the error hook to get the error and show it in the UI and handle 404 errors differently.

Jokedisplay can delete a joke, but this is now a relative URL using a action="/destroy". This is a relative URL that will call the route module with the action destroy. Defined with file based routing. It's using the action to delete the joke from the database, and redirect. Web standard stuff that at least for me is very unfamiliar as a React SPA dev originally. Delete checks for the intent to be expected. This can be used to handle multiple actions in the same route module. Then deletes from the db and redirects.

Enhanced with a disabled button again when the navigation is not idle and is on the intent "delete".

It can also be favorited. This triggers the relative URL action="/". This is a relative URL that will call the route module with the action favorite. Here we use a fetcher Form because we are not navigating anywhere and we dont want to trigger a new push to the router. We can get the state of this fetcher form locally and do another optimistic update.

## Progressive enhancement turn off JS

Go to fullscreen app.

Turn off JS and see that the app still works. Web fundamentals in play to navigate, submit forms. Just lacking the client side ehancement of prefetching and client side navigation. And no client side loading state.

Can return errors from the form and delete jokes. But we dont get client side pending state or optimistic updates. Thats all a progressive enhancement of this base case web standard application.

## Conclusion

We still didnt use any useState or useEffect here. But we can of course add it to our relevant components without any problem in the future. You know how to do that! Remix solves problems with RRM and additional hooks. Can integrate any libs like normal for more react stuff. Feels native to web.
